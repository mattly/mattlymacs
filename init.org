#+TITLE: Emacs Configuration File
#+AUTHOR: Matthew Lyon
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* About
This is my Emacs configuration file written in [[http://orgmode.org][Org mode]]. I have decided to move
away from [[http://spacemacs.org][Spacemacs]] or [[https://github.com/hlissner/.emacs.d][doom-emacs]] towards a custom configuration, and
documenting my config in Org in a /literate/ fashion seems like the way to go.

** TODO Yaks to Shave:
*** something for auto-closing quotes, etc
*** TODO UI
    set the font
    text scale increase/decrease
*** TODO lisp-mode, paredit, etc
*** TODO Elisp Stuff
*** TODO Clojure Mode


** On Emacs vs. Vim, and Evil mode vs. Holy mode.

Years ago, I used vim. I wrote code mostly in dynamically-typed,
interpreted languages, working on projects of a scale for which I
could keep their structure in my head. In some cases, I made this into
an argument for microservices.

Then I worked on a fairly large Scala project, and needed something
more. The project lead wanted me to use IntelliJ, but Spacemacs was
relatively new at the time and I thought I'd give that and Ensime a
try. It was eons better than vim for working on that type of project.

I grew to like spacemacs, primarily for the which-key
functionality. That's the sort of thing you just can't do in vim
without hacking it to pieces. And then I found magit. And
org-mode. And fell in love with lisp.

Don't get me wrong, Tim Pope is an amazingly talented plugin author,
and NeoVim is making good strides, but for me it's too little, too
late. Emacs is light years ahead of vim for many things in the same
way that vim is light years ahead of Notepad.

The stereotypes are true in both directions though: Stock Emacs has
some utterly crap ergonomics. Yeah, I've mapped Caps-Lock to Control;
I even used to make that remapping a requirement of co-workers who
wanted terminal help. Where Emacs provides a better *environment* for
editing text, vim provides a better *methodology* for doing so. Modal
editing, the motion/object grammar, and leader keys are concepts I
wish would seep into more software aimed at power-users.

Here's where Emacs truly shines though: Things like Evil-mode, Hydra,
and which-key help carry those ergonomic ideas forward in ways you
simply can't do in vim. Spacemacs nailed this.

* Literate Emacs configuration with Org

The included =init.el= file should, after the first run, mirror the source
blocks in =init.org=. Running =org-babel-tangle= will extract the code blocks
from the file into a source-specific file, in this case an =.el= file.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled, and the
    tangled file is compiled."
    (when (equal (buffer-file-name)
		 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
	(org-babel-tangle)
	(byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun mattly|reload-init ()
    (interactive)
    (load-file "init.el"))
#+END_SRC

* Bootstrapping Package Management
  The =package= package is included with Emacs 24 and newer. Tell it where to
  find packages, and initialize it.
  #+BEGIN_SRC emacs-lisp
    (require 'package)
    (setq package-archives
          '(("melpa" . "https://melpa.org/packages/")
            ("gnu" . "https://elpa.gnu.org/packages/")
            ("org"   . "http://orgmode.org/elpa/")
            ("melpa-stable" . "https://stable.melpa.org/packages/")))
    (package-initialize)
  #+END_SRC
   
** use-package
  When reading about how other people manage their own Emacs config, the
  top thing people seem to be happiest with is switching to
  [[https://github.com/jwiegley/use-package][use-package]]. In vim-land, I used my own [[https://github.com/mattly/bork][bork]] project to manage vim
  plugins and never got into the many plugin managers that were becoming
  vogue when I switched away, and I don't have any experience with
  managing Emacs packages outside of Spacemacs, so I'm going to trust
  people on this. =use-package= seems nice from what I've seen.
  
  If it's not installed, we need to install it, and then we need to make
  sure it's installed.
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
            (package-refresh-contents)
            (package-install 'use-package))

    (eval-when-compile
      (require 'use-package))

    (use-package try :ensure t)
  #+END_SRC

  Ensure all packages are installed; if they are not, go and get
  them. This configuration is stored in version control and used on
  multiple machines, and we shouldn't have to think about whether or not
  we've installed them on a particular one.
  #+BEGIN_SRC emacs-lisp
    (setq use-package-always-ensure t)
  #+END_SRC

* Sanitizing Emacs
** Changing Defaults
   
   I'm not a fan of most of the Emacs defaults. Thankfully, I don't have to be.
   
   First of all, let's use UTF-8 everywhere. It's 2017, for crying out loud.
   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'set-charset-priority)
       (set-charset-priority 'unicode))
     (prefer-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (setq locale-coding-system 'utf-8)
     (setq-default buffer-file-coding-system 'utf-8)
   #+END_SRC
   
   Disable the splash screen
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t
           inhibit-startup-echo-area-message user-login-name
           inhibit-default-init t
           initial-major-mode 'text-mode
           initial-scratch-message "Welcome to mattlymacs")
   #+END_SRC
   
   Some variables are buffer-local, and sanity is achieved with =setq-default=:
   #+BEGIN_SRC emacs-lisp
     (setq-default fill-column 80)  ; line-width for auto format, warnings, etc
   #+END_SRC
   
   I'm not a fan of Customize, or the noise it generates.
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "custom.el"))
     (load custom-file t)
   #+END_SRC
   
** Local Directories
   Some places to keep things
   #+BEGIN_SRC emacs-lisp
     (defvar mattlymacs-dir (expand-file-name user-emacs-directory)
       "The path to the emacs.d directory")

     (defvar mattlymacs-local-dir (concat mattlymacs-dir ".local/")
       "Root directory for local Emacs files. Use this as storage for files that
        are safe to share across computers.")

     (defvar mattlymacs-cache-dir (concat mattlymacs-dir "cache/")
       "Volatile storage. We can write a function to purge it. It shouldn't be in
       source control.")

     (defvar mattlymacs-packages-dir (concat mattlymacs-dir "packages/")
       "Where package.el plugins are stored.")

     (setq-default
      abbrev-file-name (concat mattlymacs-local-dir "abbrev.el")
      auto-save-list-file-name (concat mattlymacs-cache-dir "autosave")
      backup-directory-alist (list (cons "." (concat mattlymacs-cache-dir "backup/")))
      pcache-directory (concat mattlymacs-cache-dir "pcache/"))
   #+END_SRC
** Programming Helpers
   The included =cl-lib= module contains many functions from common lisp. Quite
   frankly, I'm not very clear yet on where common lisp ends and emacs begins.
   #+BEGIN_SRC emacs-lisp
     (require 'cl-lib)
   #+END_SRC
   
** Initialization Hooks

   #+BEGIN_SRC emacs-lisp
     (defvar mattlymacs-init-hook nil
       "A list of hooks to run when initialized")

     (defun mattly|initialize ()
       (run-hooks 'mattlymacs-init-hook))   

     (add-hook 'emacs-startup-hook #'mattly|initialize)
   #+END_SRC
   
** Package Improvements
*** which-key
    =which-key= might be one of the best new things in power-user interfaces to
    come along in years. Having all the commands in the word available at your
    fingertips is great, but without a good discoverability mechanism it doesn't
    do much good.
    #+BEGIN_SRC emacs-lisp
      (use-package which-key
	:commands (which-key-mode)
	:diminish t
	:init (which-key-mode)
	:config
	(setq which-key-sort-order 'which-key-key-order-alpha
	      which-key-idle-delay 0.25))
    #+END_SRC

*** hydra
    =hydra= is =which-key='s beautiful companion. There are some recipes to crib
    on the [[https://github.com/abo-abo/hydra/wiki][wiki]].
    #+BEGIN_SRC emacs-lisp
      (use-package hydra)
    #+END_SRC

* User Interface
** Emacs Settings
  First, set some things
  #+BEGIN_SRC emacs-lisp
    (fset #'yes-or-no-p #'y-or-n-p) ; y/n instead of yes/no

    (setq-default
     bidi-display-reordering nil ; disable bidirectional text for tiny performance boost
     blink-matching-paren nil    ; don't blink--too distracting
     cursor-in-non-selected-windows nil  ; hide cursors in other windows
     frame-inhibit-implied-resize t
     ;; remove continuation arrow on right fringe
     fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist)
                                  fringe-indicator-alist)
     highlight-nonselected-windows nil
     indicate-buffer-boundaries nil
     indicate-empty-lines nil
     max-mini-window-height 0.3
     mode-line-default-help-echo nil ; disable mode-line mouseovers
     split-width-threshold nil       ; favor horizontal splits
     uniquify-buffer-name-style 'forward
     use-dialog-box nil              ; always avoid GUI
     visible-cursor nil
     x-stretch-cursor nil
     ;; defer jit font locking slightly to [try to] improve Emacs performance
     jit-lock-defer-time nil
     jit-lock-stealth-nice 0.1
     jit-lock-stealth-time 0.2
     jit-lock-stealth-verbose nil
     ;; `pos-tip' defaults
     pos-tip-internal-border-width 6
     pos-tip-border-width 1
     ;; no beeping or blinking please
     ring-bell-function #'ignore
     visible-bell nil)

  #+END_SRC
  
  Kill some GUI annoyances
  #+BEGIN_SRC emacs-lisp
    (tooltip-mode -1) ; relegates tooltips to the echo area
    (menu-bar-mode -1)
    (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
  #+END_SRC
  
** Operating System Basics
   I mostly use emacs on macOS, but that might change in the near future. I'd
   rather not bake in the assumption.
   #+BEGIN_SRC emacs-lisp
     (defconst IS-MAC   (eq system-type 'darwin))
     (defconst IS-LINUX (eq system-type 'gnu/linux))
   #+END_SRC
   
** Macintosh Setup
   These seem to be the defaults on [[https://bitbucket.org/mituharu/emacs-mac/overview][RailwayCat's Emacs-mac]], but I prefer to be
   explicit when possible.
   #+BEGIN_SRC emacs-lisp
     (when IS-MAC
       (setq mac-command-modifier 'meta
             mac-option-modifier 'alt)
       (when (require 'osx-clipboard nil t)))
         ;; (osx-clipboard-mode +1)))
   #+END_SRC

** Theme
   Eventually I'm going to publish this theme.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'custom-theme-load-path "/Users/mattly/projects/emacs/akkala-theme/")
     (add-to-list 'load-path "/Users/mattly/projects/emacs/akkala-theme/")
     (require 'akkala-themes)
     (load-theme 'akkala-basic)
   #+END_SRC

* Evil Mode
  
  A necessary evil. I don't have much to say about this beyond what I said at
  the beginning. A tidbit at the end of the =:config= section sets up the "correct"
  behavior of focusing the new window when creating a split.
  #+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :init
    (setq evil-want-C-u-scroll t
	  evil-want-visual-char-semi-exclusive t
	  evil-want-Y-yank-to-eol t
	  evil-magic t
	  evil-echo-state t
	  evil-indent-convert-tabs t
	  evil-ex-search-vim-style-regexp t
	  evil-ex-substitute-global t
	  evil-ex-visual-char-range t
	  evil-insert-skip-empty-lines t
	  evil-mode-line-format 'nil
	  evil-symbol-word-search t
	  shift-select-mode nil)
    :config
    (evil-mode +1)
    (evil-select-search-module 'evil-search-module 'evil-search)
    (defun +evil*window-follow (&rest _)  (evil-window-down 1))
    (defun +evil*window-vfollow (&rest _) (evil-window-right 1))
    (advice-add #'evil-window-split  :after #'+evil*window-follow)
    (advice-add #'evil-window-vsplit :after #'+evil*window-vfollow))
  #+END_SRC
  
** evil-commentary
   Automatically sets up =gc= and =gcc= similar to the vim plugin, also provides:

   - =gy= :: yanks (copies) the uncommented code, and comments the motion out
   - =s-/= :: comments out the current line, similar to =gcc=
  #+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :commands (evil-commentary evil-commentary-yank evil-commentary-line)
    :config
    (evil-commentary-mode 1))
  #+END_SRC
  
* Editor Niceties
  
** Recent Files
   Keep track of recent files
   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :config
       (setq recentf-max-menu-items 0
             recentf-save-file (concat mattlymacs-cache-dir "recentf")
             recentf-max-saved-items 300
             recentf-exclude (list "^/tmp" "^/ssh:" "^/var/folders/.+$"
                                   "\\.?ido\\.last$" "\\.revive$" "/TAGS$"))
       (recentf-mode 1))
   #+END_SRC


** Completion (Counsel, Ivy)

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :ensure t)

     (use-package ivy
       :ensure t
       :diminish t
       :init (ivy-mode 1)
       :config
       (setq ivy-use-virtual-buffers t
	     ivy-height 20
	     ivy-count-format "(%d/%d) ")) 

     (use-package all-the-icons-ivy
       :config
       (all-the-icons-ivy-setup))
   #+END_SRC

** Pairings & Indentation
*** Aggressive Indent
    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
	:defer t
	:config
	(global-aggressive-indent-mode 1))
    #+END_SRC
*** SmartParens
    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
	:defer t
	:commands (sp-split-sexp sp-newline sp-up-sexp)
	:init
	(setq sp-show-pair-delay 0.2
	      sp-show-pair-from-inside t)
	:config
	(require 'smartparens-config)
	(show-smartparens-global-mode +1)
	(sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))

    #+END_SRC
** Miscellany
   Handy package for easy-peasy restarts when you need them.
   #+BEGIN_SRC emacs-lisp
     (use-package restart-emacs
       :defer t)
    #+END_SRC

* Project Management
  
** Projectile
   One of my first big gripes when moving to Emacs from vim was, I was used to working with
   per-project vim instances under tmux, so buffers were naturally isolated based on where
   the vim instance was created from.
   Working in the Emacs GUI, you don't really have that. Buffers are shared across all frames,
   and if you tend to have multiple projects open (as I do), it can get confusing quickly.

   [[https://github.com/bbatsov/projectile][Projectile]] aims to fix that.
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :demand t
       :init
       (setq
        projectile-cache-file (concat mattlymacs-cache-dir "projectile.cache")
        projectile-enable-caching (not noninteractive)
        projectile-globally-ignored-directories `(,mattlymacs-local-dir ".sync")
        projectile-globally-ignored-file-suffixes '(".elc")
        projectile-globally-ignored-files '(".DS_Store")
        projectile-indexing-method 'alien
        projectile-known-projects-file (concat mattlymacs-cache-dir "projectile.projects")
        projectile-require-project-root nil
        projectile-project-root-files
        '(".git" ".hg" ".project" "package.json"))
       :config
       (add-hook 'mattlymacs-init-hook #'projectile-mode))

   #+END_SRC

** Magit
   
   [[https://magit.vc][Magit]] is pretty awesome, and I say that as someone who used to prefer the
   command line, and came up with all sorts of pithy aliases in his [[https://github.com/mattly/dotfiles/blob/master/configs/gitconfig#L46][gitconfig]]
   to handle common operations. I guess I had a sort-of stockholm syndrome for
   git's poor user interface.
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :commands (magit-status magit-list-repositories))
   #+END_SRC
   
   I'm not yet using =magit-list-repositories= regularly, but in the meantime
   it's a nice alternative to what spacemacs has in "list projects"

   #+BEGIN_SRC emacs-lisp
     (setq magit-repository-directories
           '("~/code" "~/projects"))
   #+END_SRC

*** Evil for Magit
   #+BEGIN_SRC emacs-lisp
     (use-package evil-magit
       :defer t
       :config
       (require 'evil-magit))
   #+END_SRC
 
* Lisp
  People who complain about the abundance of parenthesis in lisps miss the
  point. In over two years of working primarily with lisps full-time, the only
  times I've had to think about managing parenthesis manually was when I was
  making a small edit to something in the GitHub editor or the like. And sure,
  I usually screw it up. But the whole point of having parenthesis and spaces
  as your primary syntax delimiters is to enable _structural editing_, a
  powerful idea and practice that's difficult to execute well in languages which
  complicate their syntax away from its strucutre.
  
  If you use an auto-close or auto-pair style plugin, that automatically inserts
  a closing paren, bracket, quote, or such, or highlights its compliement, you 
  already practice a weak form of structural editing -- the editor knows that 
  certain characters form nodes in a syntax tree, and helps to both ensure the
  integrity of that tree and highlight its structure. Structural editing is that,
  but much more powerful.
  
** Parinfer
   As an initial experiment, I'm seeing how far I can get with the lighter
   weight [[https://shaunlebron.github.io/parinfer/][Parinfer]] before I feel the need to add something a bit heavier. I used
   parinfer solely when trying out Atom briefly, and while I feel Atom has a long
   way to go before it's really usable for me, I did quite like parinfer.

   #+BEGIN_SRC emacs-lisp
     (use-package parinfer
       :ensure t
       :init
       (progn
         (setq parinfer-extensions
               '(defaults
                  pretty-parens
                  evil
                  smart-yank))
         (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)))
   #+END_SRC

* Key Bindings
  I've come to adore the spacemacs binding grammar for how it provides a
  similar sort of pattern to file/buffer/window/etc commands as vim's grammar
  does to text manipulation. 

** General
   #+BEGIN_SRC emacs-lisp
     (use-package general
       :commands (general-imap general-emap general-nmap general-vmap general-omap
		  general-mmap general-rmap general-otomap general-itomap general-iemap
		  general-nvmap general-tomap)
       :config
       (general-evil-setup t))
   #+END_SRC

** Menu System
   First, define our leaders:
   #+BEGIN_SRC emacs-lisp
     (defvar main-leader-key "SPC")
     (defvar minor-mode-leader-key ",")
   #+END_SRC 
   
   Then, Setup our under-main-leader keybindings:
   #+BEGIN_SRC emacs-lisp 
     (general-mmap
      :prefix "SPC"
      "" nil
      "/" '(counsel-rg :which-key "search in project")
      "TAB" '(ivy-switch-buffer :which-key "prev buffer")
      "SPC" '(counsel-M-x :which-key "M-x")

      "b" '(:ignore t :which-key "buffer")
      "bb" '(buffer-menu :which-key "menu")
      "bd" '(evil-delete-buffer :which-key "delete")
      "bD" '(kill-buffer-and-window :which-key "delete & window")

      "f" '(:ignore t :which-key "file")
      "fD" '(delete-file :which-key "delete (any file)")
      "ff" '(counsel-find-file :which-key "find file")
      "fr" '(counsel-recentf :which-key "recent files")
      "fR" '(rename-file :which-key "rename (any file)")
      "fs" '(save-buffer :which-key "save")

      "g" '(:ignore t :which-key "git")
      "gb" '(magit-blame :which-key "blame")
      "gf" '(counsel-git :which-key "find file")
      "gg" '(counsel-git-grep :which-key "git grep")
      "gs" '(magit-status :which-key "status")

      "h" '(:ignore t :which-key "help")
      "hf" '(counsel-describe-function :which-key "describe function")
      "hF" '(counsel-describe-face :which-key "describe face")
      "hk" '(describe-key :which-key "describe key")
      "hv" '(counsel-describe-variable :which-key "describe variable")

      "p" '(:ignore t :which-key "project")
      "pf" '(projectile-find-file :which-key "find file")
      "pp" '(projectile-switch-project :which-key "switch project")
      "pr" '(projectile-recentf :which-key "recent files")
      "px" '(projectile-invalidate-cache :which-key "invalidate cache")

      "q" '(:ignore t :which-key "quit")
      "qr" '(restart-emacs :which-key "restart")
      "qq" '(evil-save-and-quit :which-key "quit and save")

      "w" '(:ignore t :which-key "window")
      "wh" '(evil-window-left :which-key "go left")
      "wj" '(evil-window-down :which-key "go down")
      "wk" '(evil-window-up :which-key "go up")
      "wl" '(evil-window-right :which-key "go right")
      "wH" '(evil-window-move-far-left :which-key "move far left")
      "wJ" '(evil-window-move-very-bottom :which-key "move far bottom")
      "wK" '(evil-window-move-very-top :which-key "move far top")
      "wL" '(evil-window-move-far-right :which-key "move far right")
      "ws" '(evil-window-split :which-key "split left")
      "wv" '(evil-window-vsplit :which-key "split below")
      "wd" '(evil-window-delete :which-key "delete")

      "\\" '(:ignore t :which-key "config")
      "\\r" '(mattly|reload-init :which-key "reload"))
   #+END_SRC

** Evil Motion (Normal, Visual, Operator) Mappings
  #+BEGIN_SRC emacs-lisp
    (general-mmap
     "M-x" 'counsel-M-x)
  #+END_SRC
   
   
* Major Modes (file types, languages, etc)
** Elisp
** Org
   Org is as close to a realization of the editable, interactive, embeddable
   content varietal document as I've seen since Steve Jobs killed OpenDoc back
   in the 90s. Aping that was one of the first things I tried to do as a personal
   project after I first learned how to program something more complicated than a
   shell script. I failed because, well, I wasn't ready yet. Twelve years later,
   I'm still not ready, so I use org-mode.
   #+BEGIN_SRC emacs-lisp
     (use-package org-plus-contrib
       :defer t
       :config
       (+org|init-babel))
   #+END_SRC
*** org packages
**** org-bullets
    Yeah so org-bullets is one of those eye candy things that actually makes it
    feel like you're not really using a forty-year old program. That counts
    for something.
    #+BEGIN_SRC emacs-lisp
      (use-package org-bullets
	:defer t
	:commands (org-bullets-mode)
	:init
	(setq org-bullets-bullet-list '("§" "𝟤" "𝟥" "𝟦" "𝟧" "𝟨" "𝟩" "𝟪" "𝟫"))
	(setq org-bullets-face-name 'org-bullet))
    #+END_SRC
   
    #+BEGIN_SRC emacs-lisp
      (defun +org|init ()
	;; (+org|init-keybinds)
	(org-bullets-mode 1))
    #+END_SRC
**** org-babel
     What languages do we want org to handle?
     #+BEGIN_SRC emacs-lisp
       (setq org-babel-load-languages '())
       (defvar mattly|org-babel-load-languages
	 '(emacs-lisp))
     #+END_SRC

     Babel is included with org, though apparently available as =ob= on the
     (insecure) org repository. Instead of using =use-package= just configure it
     in a function called by the org's =:config= option.
     #+BEGIN_SRC emacs-lisp
       (defun +org|init-babel ()
	 (setq org-src-fontify-natively t
	       org-src-tab-acts-natively t
	       org-src-window-setup 'other-window)

	 (org-babel-do-load-languages
	  'org-babel-load-languages
	  (mapcar (lambda (sym) (cons sym t)) mattly|org-babel-load-languages))

	 (add-hook 'org-src-mode-hook
	     (lambda () (when header-line-format (setq header-line-format nil)))))
     #+END_SRC

**** org-evil
     =org-evil= defines some [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/keythemes.org][useful key bindings]] and has some duplication with
     the bindings I declare below, but it also has movement by element and
     additional text objects like =e= for an object and =E= for an element.
     #+BEGIN_SRC emacs-lisp
       (use-package org-evil
	 :defer t
	 :diminish t
	 :after org
	 :config
	 (add-hook 'org-mode-hook 'evil-org-mode)
	 (add-hook 'evil-org-mode-hook
	     (lambda () (evil-org-set-key-theme)))) 
     #+END_SRC
*** key bindings
    I was hoping to make an evil-mode similar to spacemacs' =evil-lisp-state=
    but I couldn't figure out how to do it in a way that keeps =which-key= in
    view the way spacemacs does. And, sadly, these operations aren't things I
    have in muscle memory yet, and they won't ever get there without on-screen
    reminders about which-keys I have to press. So, I'm using =hydra= for now,
    which seems to be awesome in its own right.

    - bindings for table editing
    
   #+BEGIN_SRC emacs-lisp
     (general-define-key
      :states '(normal visual operator)
      :keymaps 'org-mode-map
      "j" 'evil-next-visual-line
      "k" 'evil-previous-visual-line
      "RET" 'org-return-indent)

     (general-define-key
      :prefix ","
      :states '(normal visual)
      :keymaps 'org-mode-map
      "c" '(org-edit-special :which-key "edit special")
      "d" '(org-insert-drawer :which-key "insert drawer")
      "h" '(org-insert-heading-respect-content :which-key "insert heading after")
      "H" '(org-insert-subheading :which-key "insert subheading here"))

     (defhydra mattly|hydra-org-structure (:color pink)
       "
     ^Nav^               ^Subtree^          ^Node^
     ^^^^^^^^^-----------------------------------------------
     _h_: up heading     _H_: promote       _N_: promote
     _j_: next heading   _J_: move down     _P_: demote
     _k_: prev heading   _K_: move up
     _n_: next sibling   _L_: demote
     _p_: prev sibling

     "
       ("h" outline-up-heading)
       ("j" org-next-visible-heading)
       ("k" org-previous-visible-heading)
       ("n" org-forward-heading-same-level)
       ("p" org-backward-heading-same-level)
       ("H" org-promote-subtree)
       ("J" org-move-subtree-down)
       ("K" org-move-subtree-up)
       ("L" org-demote-subtree)
       ("N" org-do-promote)
       ("P" org-do-demote)
       ("q" nil "quit")
       ("ESC" nil "quit"))

     (general-define-key
      :prefix "SPC"
      :states '(normal visual operator)
      :keymaps 'org-mode-map
      "k" '(mattly|hydra-org-structure/body :which-key "org structure"))

     (general-define-key
      :prefix ","
      :states '(normal visual)
      :keymaps 'org-src-mode-map
      "c" '(org-edit-src-exit :which-key "save and exit")
      "k" '(org-edit-src-abort :which-key "abort and exit"))
  #+END_SRC
