#+TITLE: Emacs Configuration File
#+AUTHOR: Matthew Lyon
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* About
This is my Emacs configuration file written in [[http://orgmode.org][Org mode]]. I have decided to move
away from [[http://spacemacs.org][Spacemacs]] or [[https://github.com/hlissner/.emacs.d][doom-emacs]] towards a custom configuration, and
documenting my config in Org in a /literate/ fashion seems like the way to go.

** On Emacs vs. Vim, and Evil mode vs. Holy mode.

Years ago, I used vim. I wrote code mostly in dynamically-typed,
interpreted languages, working on projects of a scale for which I
could keep their structure in my head. In some cases, I made this into
an argument for microservices.

Then I worked on a fairly large Scala project, and needed something
more. The project lead wanted me to use IntelliJ, but Spacemacs was
relatively new at the time and I thought I'd give that and Ensime a
try. It was eons better than vim for working on that type of project.

I grew to like spacemacs, primarily for the which-key
functionality. That's the sort of thing you just can't do in vim
without hacking it to pieces. And then I found magit. And
org-mode. And fell in love with lisp.

Don't get me wrong, Tim Pope is an amazingly talented plugin author,
and NeoVim is making good strides, but for me it's too little, too
late. Emacs is light years ahead of vim for many things in the same
way that vim is light years ahead of Notepad.

The stereotypes are true in both directions though: Stock Emacs has
some utterly crap ergonomics. Yeah, I've mapped Caps-Lock to Control;
I even used to make that remapping a requirement of co-workers who
wanted terminal help. Where Emacs provides a better *environment* for
editing text, vim provides a better *methodology* for doing so. Modal
editing, the motion/object grammar, and leader keys are concepts I
wish would seep into more software aimed at power-users.

Here's where Emacs truly shines though: Things like Evil-mode, Hydra,
and which-key help carry those ergonomic ideas forward in ways you
simply can't do in vim. Spacemacs nailed this.

* Literate Emacs configuration with Org

The included =init.el= file should, after the first run, mirror the source
blocks in =init.org=. Running =org-babel-tangle= will extract the code blocks
from the file into a source-specific file, in this case an =.el= file.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled, and the
    tangled file is compiled."
    (when (equal (buffer-file-name)
		 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
	(org-babel-tangle)
	(byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun mattly|reload-init ()
    (interactive)
    (load-file "init.el"))
#+END_SRC

* Bootstrapping Package Management
  The =package= package is included with Emacs 24 and newer. Tell it where to
  find packages, and initialize it.
  #+BEGIN_SRC emacs-lisp
    (require 'package)
    (setq package-archives
          '(("gnu" . "https://elpa.gnu.org/packages/")
            ("org"   . "http://orgmode.org/elpa/")
            ("melpa" . "https://melpa.org/packages/")
            ("melpa-stable" . "https://stable.melpa.org/packages/")))
    (package-initialize)
  #+END_SRC
   
** use-package
  When reading about how other people manage their own Emacs config, the
  top thing people seem to be happiest with is switching to
  [[https://github.com/jwiegley/use-package][use-package]]. In vim-land, I used my own [[https://github.com/mattly/bork][bork]] project to manage vim
  plugins and never got into the many plugin managers that were becoming
  vogue when I switched away, and I don't have any experience with
  managing Emacs packages outside of Spacemacs, so I'm going to trust
  people on this. =use-package= seems nice from what I've seen.
  
  If it's not installed, we need to install it, and then we need to make
  sure it's installed.
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    (eval-when-compile
      (require 'use-package))

    (use-package try :ensure t)
  #+END_SRC

  Ensure all packages are installed; if they are not, go and get
  them. This configuration is stored in version control and used on
  multiple machines, and we shouldn't have to think about whether or not
  we've installed them on a particular one.
  #+BEGIN_SRC emacs-lisp
    (setq use-package-always-ensure t)
  #+END_SRC

* Sanitizing Emacs
** Changing Defaults
   
   I'm not a fan of most of the Emacs defaults. Thankfully, I don't have to be.
   
   First of all, let's use UTF-8 everywhere. It's 2017, for crying out loud.
   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'set-charset-priority)
       (set-charset-priority 'unicode))
     (prefer-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (setq locale-coding-system 'utf-8)
     (setq-default buffer-file-coding-system 'utf-8)
   #+END_SRC
   
   Disable the splash screen
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t
           inhibit-startup-echo-area-message user-login-name
           inhibit-default-init t
           initial-major-mode 'text-mode
           initial-scratch-message nil)
   #+END_SRC
   
   Some variables are buffer-local, and sanity is achieved with =setq-default=:
   #+BEGIN_SRC emacs-lisp
     (setq-default fill-column 79)  ; line-width for auto format, warnings, etc
   #+END_SRC
   
   I'm not a fan of Customize, or the noise it generates.
   #+BEGIN_SRC emacs-lisp
     (setq custom-file "/dev/null")
     (load custom-file t)
   #+END_SRC
   
** Local Directories
   Some places to keep things
   #+BEGIN_SRC emacs-lisp
     (defvar mattlymacs-dir (expand-file-name user-emacs-directory)
       "The path to the emacs.d directory")

     (defvar mattlymacs-cache-dir (concat mattlymacs-dir "/cache/")
       "Volatile storage. We can write a function to purge it. It shouldn't be in
       source control.")

     (defvar mattlymacs-package-dir (concat mattlymacs-dir "/packages/")
       "Where package.el plugins are stored.")
   #+END_SRC
** Programming Helpers
   The included =cl-lib= module contains many functions from common lisp. Quite
   frankly, I'm not very clear yet on where common lisp ends and emacs begins.
   #+BEGIN_SRC emacs-lisp
     (require 'cl-lib)
   #+END_SRC
   
** Package Improvements
   
*** smex
    Smex shows various options for =M-x= commands. It's probably just a
    temporary fling until I get around to installing counsel.
   #+BEGIN_SRC emacs-lisp
  (use-package smex
    :config (smex-initialize))
   #+END_SRC
   
*** which-key
    =which-key= might be one of the best new things in power-user interfaces to
    come along in years. Having all the commands in the word available at your
    fingertips is great, but without a good discoverability mechanism it doesn't
    do much good.
    #+BEGIN_SRC emacs-lisp
  (use-package which-key
    :commands (which-key-mode)
    :config
    (add-hook 'window-setup-hook #'which-key-mode))
    #+END_SRC
    
* User Interface
  First, set some things
  #+BEGIN_SRC emacs-lisp
    (fset #'yes-or-no-p #'y-or-n-p) ; y/n instead of yes/no

    (setq-default
     bidi-display-reordering nil ; disable bidirectional text for tiny performance boost
     blink-matching-paren nil    ; don't blink--too distracting
     cursor-in-non-selected-windows nil  ; hide cursors in other windows
     frame-inhibit-implied-resize t
     ;; remove continuation arrow on right fringe
     fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist)
                                  fringe-indicator-alist)
     highlight-nonselected-windows nil
     indicate-buffer-boundaries nil
     indicate-empty-lines nil
     max-mini-window-height 0.3
     mode-line-default-help-echo nil ; disable mode-line mouseovers
     split-width-threshold nil       ; favor horizontal splits
     uniquify-buffer-name-style 'forward
     use-dialog-box nil              ; always avoid GUI
     visible-cursor nil
     x-stretch-cursor nil
     ;; defer jit font locking slightly to [try to] improve Emacs performance
     jit-lock-defer-time nil
     jit-lock-stealth-nice 0.1
     jit-lock-stealth-time 0.2
     jit-lock-stealth-verbose nil
     ;; `pos-tip' defaults
     pos-tip-internal-border-width 6
     pos-tip-border-width 1
     ;; no beeping or blinking please
     ring-bell-function #'ignore
     visible-bell nil)

  #+END_SRC
  
  Kill some GUI annoyances
  #+BEGIN_SRC emacs-lisp
    (tooltip-mode -1) ; relegates tooltips to the echo area
    (menu-bar-mode -1)
    (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
  #+END_SRC
  
** Operating System Basics
   I mostly use emacs on macOS, but that might change in the near future. I'd
   rather not bake in the assumption.
   #+BEGIN_SRC emacs-lisp
     (defconst IS-MAC   (eq system-type 'darwin))
     (defconst IS-LINUX (eq system-type 'gnu/linux))
   #+END_SRC
   
** Macintosh Setup
   These seem to be the defaults on [[https://bitbucket.org/mituharu/emacs-mac/overview][RailwayCat's Emacs-mac]], but I prefer to be
   explicit when possible.
   #+BEGIN_SRC emacs-lisp
     (when IS-MAC
       (setq mac-command-modifier 'meta
             mac-option-modifier 'alt)
       (when (require 'osx-clipboard nil t)))
         ;; (osx-clipboard-mode +1)))
   #+END_SRC

* Evil Mode
  
  A necessary evil. I don't have much to say about this beyond what I said at
  the beginning. A tidbit at the end of the =:config= section sets up the "correct"
  behavior of focusing the new window when creating a split.
  #+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :init
    (setq evil-want-C-u-scroll t
	  evil-want-visual-char-semi-exclusive t
	  evil-want-Y-yank-to-eol t
	  evil-magic t
	  evil-echo-state t
	  evil-indent-convert-tabs t
	  evil-ex-search-vim-style-regexp t
	  evil-ex-substitute-global t
	  evil-ex-visual-char-range t
	  evil-insert-skip-empty-lines t
	  evil-mode-line-format 'nil
	  evil-symbol-word-search t
	  shift-select-mode nil)
    :config
    (evil-mode +1)
    (evil-select-search-module 'evil-search-module 'evil-search)
    (defun +evil*window-follow (&rest _)  (evil-window-down 1))
    (defun +evil*window-vfollow (&rest _) (evil-window-right 1))
    (advice-add #'evil-window-split  :after #'+evil*window-follow)
    (advice-add #'evil-window-vsplit :after #'+evil*window-vfollow))
  #+END_SRC
  
** evil-commentary
   Automatically sets up =gc= and =gcc= similar to the vim plugin, also provides:

   - =gy= :: yanks (copies) the uncommented code, and comments the motion out
   - =s-/= :: comments out the current line, similar to =gcc=
  #+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :commands (evil-commentary evil-commentary-yank evil-commentary-line)
    :config
    (evil-commentary-mode 1))
  #+END_SRC
  
* Editor Niceties
  
** Recent Files
   Keep track of recent files
   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :config
       (setq recentf-max-menu-items 0
             recentf-max-saved-items 300
             recentf-exclude (list "^/tmp" "^/ssh:" "^/var/folders/.+$"
                                   "\\.?ido\\.last$" "\\.revive$" "/TAGS$"))
       (recentf-mode 1))
   #+END_SRC

* Project Management
  
** Projectile
   One of my first big gripes when moving to Emacs from vim was, I was used to working with
   per-project vim instances under tmux, so buffers were naturally isolated based on where
   the vim instance was created from.
   
   Working in the Emacs GUI, you don't really have that. Buffers are shared across all frames,
   and if you tend to have multiple projects open (as I do), it can get confusing quickly.

   [[https://github.com/bbatsov/projectile][Projectile]] aims to fix that.
   
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :demand t)
   #+END_SRC

** Magit
   
   [[https://magit.vc][Magit]] is pretty awesome, and I say that as someone who used to prefer the
   command line, and came up with all sorts of pithy aliases in his [[https://github.com/mattly/dotfiles/blob/master/configs/gitconfig#L46][gitconfig]]
   to handle common operations. I guess I had a sort-of stockholm syndrome for
   git's poor user interface.
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :commands (magit-status magit-list-repositories))
   #+END_SRC
   
   I'm not yet using =magit-list-repositories= regularly, but in the meantime
   it's a nice alternative to what spacemacs has in "list projects"

   #+BEGIN_SRC emacs-lisp
     (setq magit-repository-directories
           '("~/code" "~/projects"))
   #+END_SRC

* Lisp
  People who complain about the abundance of parenthesis in lisps miss the
  point. In over two years of working primarily with lisps full-time, the only
  times I've had to think about managing parenthesis manually was when I was
  making a small edit to something in the GitHub editor or the like. And sure,
  I usually screw it up. But the whole point of having parenthesis and spaces
  as your primary syntax delimiters is to enable _structural editing_, a
  powerful idea and practice that's difficult to execute well in languages which
  complicate their syntax away from its strucutre.
  
  If you use an auto-close or auto-pair style plugin, that automatically inserts
  a closing paren, bracket, quote, or such, or highlights its compliement, you 
  already practice a weak form of structural editing -- the editor knows that 
  certain characters form nodes in a syntax tree, and helps to both ensure the
  integrity of that tree and highlight its structure. Structural editing is that,
  but much more powerful.
  
** Parinfer
   As an initial experiment, I'm seeing how far I can get with the lighter
   weight [[https://shaunlebron.github.io/parinfer/][Parinfer]] before I feel the need to add something a bit heavier. I used
   parinfer solely when trying out Atom briefly, and while I feel Atom has a long
   way to go before it's really usable for me, I did quite like parinfer.

   #+BEGIN_SRC emacs-lisp
     (use-package parinfer
       :ensure t
       :init
       (progn
         (setq parinfer-extensions
               '(defaults
                  pretty-parens
                  evil
                  smart-yank))
         (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)))
   #+END_SRC

* Key Bindings
  I've come to adore the spacemacs binding grammar for how it provides a
  similar sort of pattern to file/buffer/window/etc commands as vim's grammar
  does to text manipulation. 

** Easy Binding Macro
  This keybinding macro is taken almost wholesale from [[https://github.com/hlissner/.emacs.d/blob/99ef794f9261df61f424cec9fbcffe3d54b0b355/core/core-keybinds.el][doom-emacs]]. Since it's not a
  standalone, I had to copy it.
  #+BEGIN_SRC emacs-lisp
    (require 'keybinds (concat (expand-file-name user-emacs-directory) "keybinds"))
  #+END_SRC
  
  
** Help
   One of the things that impressed me most about Emacs is the built-in help
   system. While it's fairly easy to remember =C-x k= for =describe-key=, for
   example, and while =which-key= makes it easy to discover the remainder of
   the help functions, I'd prefer to put them under a leader binding.
   
   #+BEGIN_SRC emacs-lisp 
     (map!
      :leader
      (:desc "help" :prefix "h"
        :desc "describe function" :n "f" #'describe-function
        :desc "describe key" :n "k" #'describe-key
        :desc "describe variable" :n "v" #'describe-variable))
   #+END_SRC

** All Mode Mappings
  #+BEGIN_SRC emacs-lisp
    (map!
     :nvime "M-x" #'smex)
  #+END_SRC
   
** Buffer Manipulation
   #+BEGIN_SRC emacs-lisp
     (map!
      :leader
      (:desc "buffer" :prefix "b"
        :desc "menu" :n "b" #'buffer-menu
        :desc "delete" :n "d" #'evil-delete-buffer))
   #+END_SRC
  
** File Manipulation
   #+BEGIN_SRC emacs-lisp
     (map!
      (:leader
        (:desc "files" :prefix "f"
          :desc "delete (any file)" :n "D" #'delete-file
          :desc "recent file list" :n "r" #'recentf-open-files
          :desc "rename (any file)" :n "R" #'rename-file
          :desc "save" :n "s" #'save-buffer)))
   #+END_SRC
   
** Source Control (git)
   
   #+BEGIN_SRC emacs-lisp
     (map!
      (:leader
        (:desc "git" :prefix "g"
          :desc "blame" :n "b" #'magit-blame
          :desc "status" :n "s" #'magit-status)))
   #+END_SRC

** Window Manipulation
   
   #+BEGIN_SRC emacs-lisp
     (map!
      (:leader
        (:desc "window" :prefix "w"
          ;; navigation
          :desc "left" :n "h" #'evil-window-left
          :desc "up" :n "k" #'evil-window-up
          :desc "down" :n "j" #'evil-window-down
          :desc "right" :n "l" #'evil-window-right
          ;; opening
          :desc "split below" :n "s" #'evil-window-split
          :desc "split right" :n "v" #'evil-window-vsplit
          ;; closing
          :desc "delete" :n "d" #'evil-window-delete)))
   #+END_SRC
   
** Config File
   
   #+BEGIN_SRC emacs-lisp
  (map!
   (:leader
     (:desc "config" :prefix "\\"
       :desc "reload config" :n "r" #'mattly|reload-init)))

   #+END_SRC

* Majors
** Elisp
** Org

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :config
    (setq org-src-window-setup 'current-window))
#+END_SRC
    
*** Babel
    
    One bit of sanity

  #+BEGIN_SRC emacs-lisp
    (defun +org|init-babel ()
      (setq org-src-window-setup 'current-window))

    (add-hook 'org-mode-hook #'+org|init-babel)
  #+END_SRC 
