#+TITLE: Emacs Configuration File
#+AUTHOR: Matthew Lyon
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* About
This is my Emacs configuration file written in [[http://orgmode.org][Org mode]]. I have decided to move
away from [[http://spacemacs.org][Spacemacs]] or [[https://github.com/hlissner/.emacs.d][doom-emacs]] towards a custom configuration, and
documenting my config in Org in a /literate/ fashion seems like the way to go.

** On Emacs vs. Vim, and Evil mode vs. Holy mode.

Years ago, I used vim. I wrote code mostly in dynamically-typed,
interpreted languages, working on projects of a scale for which I
could keep their structure in my head. In some cases, I made this into
an argument for microservices.

Then I worked on a fairly large Scala project, and needed something
more. The project lead wanted me to use IntelliJ, but Spacemacs was
relatively new at the time and I thought I'd give that and Ensime a
try. It was eons better than vim for working on that type of project.

I grew to like spacemacs, primarily for the which-key
functionality. That's the sort of thing you just can't do in vim
without hacking it to pieces. And then I found magit. And
org-mode. And fell in love with lisp.

Don't get me wrong, Tim Pope is an amazingly talented plugin author,
and NeoVim is making good strides, but for me it's too little, too
late. Emacs is light years ahead of vim for many things in the same
way that vim is light years ahead of Notepad.

The stereotypes are true in both directions though: Stock Emacs has
some utterly crap ergonomics. Yeah, I've mapped Caps-Lock to Control;
I even used to make that remapping a requirement of co-workers who
wanted terminal help. Where Emacs provides a better *environment* for
editing text, vim provides a better *methodology* for doing so. Modal
editing, the motion/object grammar, and leader keys are concepts I
wish would seep into more software aimed at power-users.

Here's where Emacs truly shines though: Things like Evil-mode, Hydra,
and which-key help carry those ergonomic ideas forward in ways you
simply can't do in vim. Spacemacs nailed this.

* Org, Tangle, init.el and you

The included =init.el= file should, after the first run, mirror the source
blocks in =init.org=. Running =org-babel-tangle= will extract the code blocks
from the file into a source-specific file, in this case an =.el= file.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled, and the
    tangled file is compiled."
    (when (equal (buffer-file-name)
		 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
	(org-babel-tangle)
	(byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun mattly|reload-init ()
    (interactive)
    (load-file "init.el"))
#+END_SRC

#+RESULTS:
: reload-init

* Package Management
  
** package.el Initialization and Repositories
   
   The =package= package is included with Emacs 24 and newer. Tell it where to
   find packages, and initialize it.
   
   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-archives
           '(("gnu" . "https://elpa.gnu.org/packages/")
             ("org"   . "http://orgmode.org/elpa/")
             ("melpa" . "https://melpa.org/packages/")
             ("melpa-stable" . "https://stable.melpa.org/packages/")))
     (package-initialize)
   #+END_SRC
   
** use-package

When reading about how other people manage their own Emacs config, the
top thing people seem to be happiest with is switching to
[[https://github.com/jwiegley/use-package][use-package]]. In vim-land, I used my own [[https://github.com/mattly/bork][bork]] project to manage vim
plugins and never got into the many plugin managers that were becoming
vogue when I switched away, and I don't have any experience with
managing Emacs packages outside of Spacemacs, so I'm going to trust
people on this. =use-package= seems nice from what I've seen.

If it's not installed, we need to install it, and then we need to make
sure it's installed.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))

  (use-package try :ensure t)
#+END_SRC

Ensure all packages are installed; if they are not, go and get
them. This configuration is stored in version control and used on
multiple machines, and we shouldn't have to think about whether or not
we've installed them on a particular one.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

* Sanitizing Emacs
** Changing Defaults
   
   I'm not a fan of most of the Emacs defaults. Thankfully, I don't have to be.
   
   First of all, let's use UTF-8 everywhere. It's 2017, for crying out loud.
   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'set-charset-priority)
       (set-charset-priority 'unicode))
     (prefer-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (setq locale-coding-system 'utf-8)
     (setq-default buffer-file-coding-system 'utf-8)
   #+END_SRC
   
   Disable the splash screen
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t
           inhibit-startup-echo-area-message user-login-name
           inhibit-default-init t
           initial-major-mode 'text-mode
           initial-scratch-message nil)
   #+END_SRC
   
   Some variables are buffer-local, and sanity is achieved with =setq-default=:
   #+BEGIN_SRC emacs-lisp
     (setq-default fill-column 79)  ; line-width for auto format, warnings, etc
   #+END_SRC
   
   I'm not a fan of Customize, or the noise it generates.
   #+BEGIN_SRC emacs-lisp
     (setq custom-file "/dev/null")
     (load custom-file t)
   #+END_SRC
   
** Programming Helpers
   The included =cl-lib= module contains many functions from common lisp. Quite
   frankly, I'm not very clear yet on where common lisp ends and emacs begins.
   #+BEGIN_SRC emacs-lisp
     (require 'cl-lib)
   #+END_SRC
   
** Package Improvements
   
*** smex
    Smex shows various options for =M-x= commands. It's probably just a
    temporary fling until I get around to installing counsel.
   #+BEGIN_SRC emacs-lisp
  (use-package smex
    :config (smex-initialize))
   #+END_SRC
   
*** which-key
    =which-key= might be one of the best new things in power-user interfaces to
    come along in years. Having all the commands in the word available at your
    fingertips is great, but without a good discoverability mechanism it doesn't
    do much good.
    #+BEGIN_SRC emacs-lisp
  (use-package which-key
    :commands (which-key-mode)
    :config
    (add-hook 'window-setup-hook #'which-key-mode))
    #+END_SRC
    
* Evil Mode
  
  A necessary evil. I don't have much to say about this beyond what I said at
  the beginning. A tidbit at the end of the =:config= section sets up the "correct"
  behavior of focusing the new window when creating a split.
  #+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :init
    (setq evil-want-C-u-scroll t
	  evil-want-visual-char-semi-exclusive t
	  evil-want-Y-yank-to-eol t
	  evil-magic t
	  evil-echo-state t
	  evil-indent-convert-tabs t
	  evil-ex-search-vim-style-regexp t
	  evil-ex-substitute-global t
	  evil-ex-visual-char-range t
	  evil-insert-skip-empty-lines t
	  evil-mode-line-format 'nil
	  evil-symbol-word-search t
	  shift-select-mode nil)
    :config
    (evil-mode +1)
    (evil-select-search-module 'evil-search-module 'evil-search)
    (defun +evil*window-follow (&rest _)  (evil-window-down 1))
    (defun +evil*window-vfollow (&rest _) (evil-window-right 1))
    (advice-add #'evil-window-split  :after #'+evil*window-follow)
    (advice-add #'evil-window-vsplit :after #'+evil*window-vfollow))
  #+END_SRC
  
** evil-commentary
   Automatically sets up =gc= and =gcc= similar to the vim plugin, also provides:

   - =gy= :: yanks (copies) the uncommented code, and comments the motion out
   - =s-/= :: comments out the current line, similar to =gcc=
  #+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :commands (evil-commentary evil-commentary-yank evil-commentary-line)
    :config
    (evil-commentary-mode 1))
  #+END_SRC
  
* Project Management
  
** Magit
   
   [[https://magit.vc][Magit]] is pretty awesome, and I say that as someone who used to prefer the
   command line, and came up with all sorts of pithy aliases in his [[https://github.com/mattly/dotfiles/blob/master/configs/gitconfig#L46][gitconfig]]
   to handle common operations. I guess I had a sort-of stockholm syndrome for
   git's poor user interface.
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :commands (magit-status magit-list-repositories))
   #+END_SRC
   
   I'm not yet using =magit-list-repositories= regularly, but in the meantime
   it's a nice alternative to what spacemacs has in "list projects"

   #+BEGIN_SRC emacs-lisp
     (setq magit-repository-directories
           '("~/code" "~/projects"))
   #+END_SRC

* Lisp
  People who complain about the abundance of parenthesis in lisps miss the
  point. In over two years of working primarily with lisps full-time, the only
  times I've had to think about managing parenthesis manually was when I was
  making a small edit to something in the GitHub editor or the like. And sure,
  I usually screw it up. But the whole point of having parenthesis and spaces
  as your primary syntax delimiters is to enable _structural editing_, a
  powerful idea and practice that's difficult to execute well in languages which
  complicate their syntax away from its strucutre.
  
  If you use an auto-close or auto-pair style plugin, that automatically inserts
  a closing paren, bracket, quote, or such, or highlights its compliement, you 
  already practice a weak form of structural editing -- the editor knows that 
  certain characters form nodes in a syntax tree, and helps to both ensure the
  integrity of that tree and highlight its structure. Structural editing is that,
  but much more powerful.
  
** Parinfer
   As an initial experiment, I'm seeing how far I can get with the lighter
   weight [[https://shaunlebron.github.io/parinfer/][Parinfer]] before I feel the need to add something a bit heavier. I used
   parinfer solely when trying out Atom briefly, and while I feel Atom has a long
   way to go before it's really usable for me, I did quite like parinfer.

   #+BEGIN_SRC emacs-lisp
     (use-package parinfer
       :ensure t
       :init
       (progn
         (setq parinfer-extensions
               '(defaults
                  pretty-parens
                  evil
                  smart-yank))
         (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)))
   #+END_SRC

* Key Bindings
** Easy Binding Macro
  This keybinding macro is taken almost wholesale from [[https://github.com/hlissner/.emacs.d/blob/99ef794f9261df61f424cec9fbcffe3d54b0b355/core/core-keybinds.el][doom-emacs]]. Since it's not a
  standalone, I had to copy it.
  #+BEGIN_SRC emacs-lisp
    (require 'keybinds (concat (expand-file-name user-emacs-directory) "keybinds"))
  #+END_SRC
  
** All Mode Mappings
  #+BEGIN_SRC emacs-lisp
    (map!
     :nvime "M-x" #'smex)
  #+END_SRC
  
** File Manipulation
   #+BEGIN_SRC emacs-lisp
     (map!
      (:leader
	(:desc "files" :prefix "f"
	  :desc "delete (any file)" :n "D" #'delete-file
	  :desc "rename (any file)" :n "R" #'rename-file
	  :desc "save" :n "s" #'save-buffer)))
   #+END_SRC
   
** Source Control (git)
   
   #+BEGIN_SRC emacs-lisp
     (map!
      (:leader
        (:desc "git" :prefix "g"
          :desc "blame" :n "b" #'magit-blame
          :desc "status" :n "s" #'magit-status)))
   #+END_SRC

** Window Manipulation
   
   #+BEGIN_SRC emacs-lisp
    (map!
     (:leader
       (:desc "window" :prefix "w"
	 ;; navigation
	 :desc "left" :n "h" #'evil-window-left
	 :desc "up" :n "k" #'evil-window-up
	 :desc "down" :n "j" #'evil-window-down
	 :desc "right" :n "l" #'evil-window-right
	 ;; opening
	 :desc "split below" :n "s" #'evil-window-split
	 :desc "split right" :n "v" #'evil-window-vsplit
	 ;; closing
	 :desc "delete" :n "d" #'evil-window-delete)))
      
   #+END_SRC
   
** Config File
   
   #+BEGIN_SRC emacs-lisp
  (map!
   (:leader
     (:desc "config" :prefix "\\"
       :desc "reload config" :n "r" #'mattly|reload-init)))

   #+END_SRC

* Majors
** Elisp
** Org

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :config
    (setq org-src-window-setup 'current-window))
#+END_SRC
    
*** Babel
    
    One bit of sanity

  #+BEGIN_SRC emacs-lisp
    (defun +org|init-babel ()
      (setq org-src-window-setup 'current-window))

    (add-hook 'org-mode-hook #'+org|init-babel)
  #+END_SRC 
