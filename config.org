#+TITLE: Emacs Configuration File
#+AUTHOR: Matthew Lyon
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* About
This is my Emacs configuration file written in [[http://orgmode.org][Org mode]]. I have decided to move
away from [[http://spacemacs.org][Spacemacs]] or [[https://github.com/hlissner/.emacs.d][doom-emacs]] towards a custom configuration, and
documenting my config in Org in a /literate/ fashion seems like the way to go.

** TODO Yaks to Shave:
*** Emacs management
    - Update package
    - remove unneded packages
*** TODO UI
    set the font
*** TODO lisp-mode, paredit, etc
*** TODO Elisp Stuff
*** TODO Clojure Mode
** On Emacs vs. Vim, and Evil mode vs. Holy mode.

Years ago, I used vim.  I wrote code mostly in dynamically-typed,
interpreted languages, working on projects of a scale for which I
could keep their structure in my head.  In some cases, I made this into
an argument for microservices.

Then I worked on a fairly large Scala project, and needed something
more.  The project lead wanted me to use IntelliJ, but Spacemacs was
relatively new at the time and I thought I'd give that and Ensime a
try.  It was eons better than vim for working on that type of project.

I grew to like spacemacs, primarily for the which-key
functionality.  That's the sort of thing you just can't do in vim
without hacking it to pieces.  And then I found magit.  And
org-mode.  And fell in love with lisp.

Don't get me wrong, Tim Pope is an amazingly talented plugin author,
and NeoVim is making good strides, but for me it's too little, too
late.  Emacs is light years ahead of vim for many things in the same
way that vim is light years ahead of Notepad.

The stereotypes are true in both directions though: Stock Emacs has
some utterly crap ergonomics.  Yeah, I've mapped Caps-Lock to Control;
I even used to make that remapping a requirement of co-workers who
wanted terminal help.  Where Emacs provides a better *environment* for
editing text, vim provides a better *methodology* for doing so.  Modal
editing, the motion/object grammar, and leader keys are concepts I
wish would seep into more software aimed at power-users.

Here's where Emacs truly shines though: Things like Evil-mode, Hydra,
and which-key help carry those ergonomic ideas forward in ways you
simply can't do in vim.  Spacemacs nailed this.

* Literate Emacs configuration with Org

  The included =init.el= file should, after the first run, mirror the source
  blocks in =init.org=.  Running =org-babel-tangle= will extract the code blocks
  from the file into a source-specific file, in this case an =.el= file. 

  #+BEGIN_SRC emacs-lisp
    (defvar mattly|config-location
      (expand-file-name (concat user-emacs-directory "config.org")))
  #+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled, and the
    tangled file is compiled."
    (when (equal (buffer-file-name) mattly|config-location)
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "config.el")))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

* Bootstrapping Package Management
  The =package= package is included with Emacs 24 and newer. Tell it where to
  find packages, and initialize it.
  #+BEGIN_SRC emacs-lisp
    (require 'package)
    (setq package-archives
          '(("melpa" . "https://melpa.org/packages/")
            ("gnu" . "https://elpa.gnu.org/packages/")
            ("org"   . "http://orgmode.org/elpa/")))
    (package-initialize)
  #+END_SRC

** use-package
  When reading about how other people manage their own Emacs config, the
  top thing people seem to be happiest with is switching to
  [[https://github.com/jwiegley/use-package][use-package]].  In vim-land, I used my own [[https://github.com/mattly/bork][bork]] project to manage vim
  plugins and never got into the many plugin managers that were becoming
  vogue when I switched away, and I don't have any experience with
  managing Emacs packages outside of Spacemacs, so I'm going to trust
  people on this.  =use-package= seems nice from what I've seen.
  
  If it's not installed, we need to install it, and then we need to make
  sure it's installed.
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
            (package-refresh-contents)
            (package-install 'use-package))

    (eval-when-compile
      (require 'use-package))

    (use-package try :ensure t)
  #+END_SRC

  Ensure all packages are installed; if they are not, go and get
  them.  This configuration is stored in version control and used on
  multiple machines, and we shouldn't have to think about whether or not
  we've installed them on a particular one.
  #+BEGIN_SRC emacs-lisp
    (setq use-package-always-ensure t)
  #+END_SRC

** updating packages
   #+BEGIN_SRC emacs-lisp
     (use-package auto-package-update
       :config
       (setq auto-package-update-delete-old-versions t))
   #+END_SRC
* Sanitizing Emacs
** Changing Defaults
   
   I'm not a fan of most of the Emacs defaults.  Thankfully, I don't have to be.
   
   First of all, let's use UTF-8 everywhere.  It's 2017, for crying out loud.
   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'set-charset-priority)
       (set-charset-priority 'unicode))
     (prefer-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (setq locale-coding-system 'utf-8)
     (setq-default buffer-file-coding-system 'utf-8)
   #+END_SRC
   
   Disable the splash screen
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t
           inhibit-startup-echo-area-message user-login-name
           inhibit-default-init t
           initial-major-mode 'text-mode
           initial-scratch-message "Welcome to mattlymacs")
   #+END_SRC
   
   Some variables are buffer-local, and sanity is achieved with =setq-default=:
   #+BEGIN_SRC emacs-lisp
     (setq-default fill-column 80)  ; line-width for auto format, warnings, etc
   #+END_SRC
   
   I'm not a fan of Customize, or the noise it generates.
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "custom.el"))
     (load custom-file t)
   #+END_SRC
   
** Local Directories
   Some places to keep things
   #+BEGIN_SRC emacs-lisp
     (defvar mattlymacs-dir (expand-file-name user-emacs-directory)
       "The path to the emacs.d directory")

     (defvar mattlymacs-local-dir (concat mattlymacs-dir ".local/")
       "Root directory for local Emacs files. Use this as storage for files that
        are safe to share across computers.")

     (defvar mattlymacs-cache-dir (concat mattlymacs-dir "cache/")
       "Volatile storage. We can write a function to purge it. It shouldn't be in
       source control.")

     (defvar mattlymacs-packages-dir (concat mattlymacs-dir "packages/")
       "Where package.el plugins are stored.")

     (setq-default
      abbrev-file-name (concat mattlymacs-local-dir "abbrev.el")
      auto-save-list-file-name (concat mattlymacs-cache-dir "autosave")
      backup-directory-alist (list (cons "." (concat mattlymacs-cache-dir "backup/")))
      pcache-directory (concat mattlymacs-cache-dir "pcache/"))
   #+END_SRC
** Programming Helpers
   The included =cl-lib= module contains many functions from common lisp.  Quite
   frankly, I'm not very clear yet on where common lisp ends and emacs begins.
   #+BEGIN_SRC emacs-lisp
     (require 'cl-lib)
   #+END_SRC
   
** Initialization Hooks

   #+BEGIN_SRC emacs-lisp
     (defvar mattlymacs-init-hook nil
       "A list of hooks to run when initialized")

     (defun mattly|initialize ()
       (run-hooks 'mattlymacs-init-hook))   

     (add-hook 'emacs-startup-hook #'mattly|initialize)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun mattly|find-dotfile ()
       "Edit `init.org' int he current window"
       (interactive)
       (find-file-existing mattly|config-location))

   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun mattly|reload-init ()
       (interactive)
       (load-file "init.el")
       (mattly|initialize))
   #+END_SRC
   
** Package Improvements
*** which-key
    =which-key= might be one of the best new things in power-user interfaces to
    come along in years.  Having all the commands in the word available at your
    fingertips is great, but without a good discoverability mechanism it doesn't
    do much good.
    #+BEGIN_SRC emacs-lisp
      (use-package which-key
	:commands (which-key-mode)
	:diminish t
	:init (which-key-mode)
	:config
	(setq which-key-sort-order 'which-key-key-order-alpha
	      which-key-idle-delay 0.25))
    #+END_SRC

*** hydra
    =hydra= is =which-key='s beautiful companion.  There are some recipes to crib
    on the [[https://github.com/abo-abo/hydra/wiki][wiki]].
    #+BEGIN_SRC emacs-lisp
      (use-package hydra)
    #+END_SRC

* User Interface
** Emacs Settings
  First, set some things
  #+BEGIN_SRC emacs-lisp
    (fset #'yes-or-no-p #'y-or-n-p) ; y/n instead of yes/no

    (setq-default
     bidi-display-reordering nil ; disable bidirectional text for tiny performance boost
     blink-matching-paren nil    ; don't blink--too distracting
     cursor-in-non-selected-windows nil  ; hide cursors in other windows
     frame-inhibit-implied-resize t
     ;; remove continuation arrow on right fringe
     fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist)
                                  fringe-indicator-alist)
     highlight-nonselected-windows nil
     indicate-buffer-boundaries nil
     indicate-empty-lines nil
     max-mini-window-height 0.3
     mode-line-default-help-echo nil ; disable mode-line mouseovers
     split-width-threshold nil       ; favor horizontal splits
     uniquify-buffer-name-style 'forward
     use-dialog-box nil              ; always avoid GUI
     visible-cursor nil
     x-stretch-cursor nil
     ;; defer jit font locking slightly to [try to] improve Emacs performance
     jit-lock-defer-time nil
     jit-lock-stealth-nice 0.1
     jit-lock-stealth-time 0.2
     jit-lock-stealth-verbose nil
     ;; `pos-tip' defaults
     pos-tip-internal-border-width 6
     pos-tip-border-width 1
     ;; no beeping or blinking please
     ring-bell-function #'ignore
     visible-bell nil)

  #+END_SRC
  
  Kill some GUI annoyances
  #+BEGIN_SRC emacs-lisp
    (tooltip-mode -1) ; relegates tooltips to the echo area
    (menu-bar-mode -1)
    (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
  #+END_SRC
  
** Operating System Basics
   I mostly use emacs on macOS, but that might change in the near future. I'd
   rather not bake in the assumption.
   #+BEGIN_SRC emacs-lisp
     (defconst IS-MAC   (eq system-type 'darwin))
     (defconst IS-LINUX (eq system-type 'gnu/linux))
   #+END_SRC
   
** Macintosh Setup
   These seem to be the defaults on [[https://bitbucket.org/mituharu/emacs-mac/overview][RailwayCat's Emacs-mac]], but I prefer to be
   explicit when possible.
   #+BEGIN_SRC emacs-lisp
     (when IS-MAC
       (setq mac-command-modifier 'meta
             mac-option-modifier 'alt)
       (when (require 'osx-clipboard nil t)))
         ;; (osx-clipboard-mode +1)))
   #+END_SRC

** Font
   Iosevka is really nice.
   #+BEGIN_SRC emacs-lisp
     (defvar mattly-font "Iosevka Light 14")
     (set-face-attribute 'default nil :font mattly-font)
     (set-frame-font mattly-font nil t)
   #+END_SRC
  
*** Text Scaling
    #+BEGIN_SRC emacs-lisp
      (use-package zoom-frm
        :defer t
        :commands (zoom-in zoom-out zoom-in/out zoom-frm-unzoom))
    #+END_SRC
** Theme
   Eventually I'm going to publish this theme.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'custom-theme-load-path "/Users/mattly/projects/emacs/akkala-theme/")
     (add-to-list 'load-path "/Users/mattly/projects/emacs/akkala-theme/")
     (require 'akkala-themes)
     (load-theme 'akkala-basic)
   #+END_SRC

** Evil Mode
   A necessary evil.  I don't have much to say about this beyond what I said at
   the beginning.  A tidbit at the end of the =:config= section sets up the "correct"
   behavior of focusing the new window when creating a split.
   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :demand t
       :init
       (setq evil-want-C-u-scroll t
             evil-want-visual-char-semi-exclusive t
             evil-want-Y-yank-to-eol t
             evil-magic t
             evil-echo-state t
             evil-indent-convert-tabs t
             evil-ex-search-vim-style-regexp t
             evil-ex-substitute-global t
             evil-ex-visual-char-range t
             evil-insert-skip-empty-lines t
             evil-mode-line-format 'nil
             evil-symbol-word-search t
             shift-select-mode nil)
       :config
       (evil-mode +1)
       (evil-select-search-module 'evil-search-module 'evil-search)
       (defun +evil*window-follow (&rest _)  (evil-window-down 1))
       (defun +evil*window-vfollow (&rest _) (evil-window-right 1))
       (advice-add #'evil-window-split  :after #'+evil*window-follow)
       (advice-add #'evil-window-vsplit :after #'+evil*window-vfollow))
   #+END_SRC
  
** Key Binding Helpers (General)
   I'm defining this here instead of the key bindings section, so I can very
   easily elsewhere in this config handle one-off bindings for small packages as
   they come up.

   [[https://github.com/noctuid/general.el][general.el]] isn't quite my dream DSL for binding keys, but it turns out that
   keybindings in emacs with evil is a pretty complex topic.  You've got various
   states & modes to worry about, mode maps, common prefixes, etc.  And it
   handles those all pretty well.
   #+BEGIN_SRC emacs-lisp
     (use-package general
       :commands (general-create-definer)
       :config
       (general-evil-setup t))
   #+END_SRC

*** Binding Helpers
    These binding helpers are useful for defining bindings with common options
    in multiple places, so I don't have to define everything at one or track down
    common options in multiple places.

    =bind-at-rest= makes bindings in normal & visual mode without a prefix, to
    accompany such vim stalwarts as =i= and =w=. They are bound to keymaps
    instead of states, because other modes (such as magit) might provide their
    own bindings on these keys and I don't want to override those.

    #+BEGIN_SRC emacs-lisp
      (general-create-definer bind-navigation
                              :keymaps '(evil-normal-state-map evil-visual-state-map evil-motion-state-map)) 
      (general-create-definer bind-motion
                              :keymaps '(evil-motion-state-map)) 
      (general-create-definer bind-operator
                              :keymaps '(evil-operator-state-map))
      (general-create-definer bind-inner-object
                              :keymaps '(evil-inner-text-objects-map))
      (general-create-definer bind-outer-object
                              :keymaps '(evil-outer-text-objects-map))
    #+END_SRC

    =bind-main-menu= makes bindings for the global menu system on =SPC= for
    at-rest modes, or in insert/emacs mode with =M-S-SPC=.
    #+BEGIN_SRC emacs-lisp
      (general-create-definer bind-main-menu
                              :prefix "SPC"
                              :non-normal-prefix "M-S-SPC"
                              :keymaps 'global
                              :states '(normal visual operator insert emacs))
    #+END_SRC

    =bind-mode-menu= makes a binding for the major-mode-specific menu system on
    =,= for at-rest modes or =M-S-,= for insert mode.
    #+BEGIN_SRC emacs-lisp
      (general-create-definer bind-mode-menu
                              :prefix ","
                              :states '(normal visual))
    #+END_SRC
** evil Plugins 
*** evil-commentary
    Automatically sets up =gc= and =gcc= similar to the vim plugin, also provides:

    - =gy= :: yanks (copies) the uncommented code, and comments the motion out
    - =s-/= :: comments out the current line, similar to =gcc=
   #+BEGIN_SRC emacs-lisp
     (use-package evil-commentary
       :commands (evil-commentary evil-commentary-yank evil-commentary-line)
       :diminish t
       :config
       (evil-commentary-mode 1))
   #+END_SRC
** Resetting Evil
   #+BEGIN_SRC emacs-lisp
     (setcdr evil-normal-state-map nil)
     (setcdr evil-visual-state-map nil)
     (setcdr evil-motion-state-map nil)
     (setcdr evil-operator-state-map nil)
   #+END_SRC
* Editor Niceties
** Recent Files
   Keep track of recent files
   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :config
       (setq recentf-max-menu-items 0
             recentf-save-file (concat mattlymacs-cache-dir "recentf")
             recentf-max-saved-items 300
             recentf-exclude (list "^/tmp" "^/ssh:" "^/var/folders/.+$"
                                   "\\.?ido\\.last$" "\\.revive$" "/TAGS$"))
       (recentf-mode 1))
   #+END_SRC

** Completion (Counsel, Ivy)

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :diminish t
       :ensure t)

     (use-package ivy
       :ensure t
       :diminish t
       :init (ivy-mode 1)
       :config
       (setq ivy-use-virtual-buffers t
             ivy-height 20
             ivy-count-format "(%d/%d) ")) 

     (use-package all-the-icons-ivy
       :diminish t
       :config
       (all-the-icons-ivy-setup))
   #+END_SRC

** Text Manipulation
*** Folding
    #+BEGIN_SRC emacs-lisp
      (use-package origami
        :diminish t
        :defer t
        :config
        (setq origami-show-fold-header t)
        (global-origami-mode))
    #+END_SRC
*** Whitespace
    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil
                    whitespace-mode nil
                    require-final-newline nil)

      (use-package ethan-wspace
        :defer t
        :diminish t
        :config
        (global-ethan-wspace-mode 1))
    #+END_SRC

*** Delimiters

**** SmartParens
     #+BEGIN_SRC emacs-lisp
       (use-package smartparens
         :defer t
         :commands (sp-split-sexp sp-newline sp-up-sexp)
         :init
         (setq sp-autowrap-region nil ; let others handle this
               sp-highlight-pair-overlay t
               sp-cancel-autoskip-on-backward-movement nil
               sp-show-pair-delay 0.2
               sp-show-pair-from-inside t)
         :config
         (require 'smartparens-config)
         (add-hook 'prog-mode-hook #'smartparens-mode)
         ;; sp interferes with replace-mode
         (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
         (add-hook 'evil-replace-state-exit-hook #'turn-on-smartparens-mode)

         (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
     #+END_SRC

**** Rainbow Delimiters
     #+BEGIN_SRC emacs-lisp
       (use-package rainbow-delimiters
         :defer t
         :init
         (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
     #+END_SRC

**** Highlight Parens
     #+BEGIN_SRC emacs-lisp
       (use-package highlight-parentheses
         :defer t
         :init
         (progn
           (add-hook 'prog-mode-hook #'highlight-parentheses-mode)
           (setq hl-paren-delay 0.2)
           (setq hl-paren-colors '("Springgreen3"
                                   "IndianRed1"
                                   "IndianRed3"
                                   "IndianRed4")))
         :config
         (set-face-attribute 'hl-paren-face nil :weight 'ultra-bold))
     #+END_SRC
*** Inflections
    kebab-case is the one true case.  kebab-case loves you.  Every other case hates
    you and wants you to suffer RSI.
    #+BEGIN_SRC emacs-lisp
      (use-package string-inflection
        :defer t
        :diminish t)
    #+END_SRC

** In-Buffer Navigation
   I'm just trying out avy for now.
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :config
       (setq avy-keys '(?a ?r ?s ?t ?n ?e ?i ?o)))
   #+END_SRC
** Miscellany
*** $EDITOR for child processes
    #+BEGIN_SRC emacs-lisp
      (use-package with-editor
        :defer t)

      (bind-mode-menu
       :keymaps 'with-editor-mode-map
       "," '(with-editor-finish :which-key "finish")
       "a" '(with-editor-cancel :which-key "cancel")
       "c" '(with-editor-finish :which-key "finish")
       "k" '(with-editor-cancel :which-key "cancel"))
    #+END_SRC
*** Fill Column Indicator
    #+BEGIN_SRC emacs-lisp
      (use-package fill-column-indicator
        :defer t
        :commands (fci-mode))
    #+END_SRC
*** Restarting
    Handy package for easy-peasy restarts when you need them.
    #+BEGIN_SRC emacs-lisp
      (use-package restart-emacs
        :defer t)
     #+END_SRC

* Project Management
** Projectile
   One of my first big gripes when moving to Emacs from vim was, I was used to working with
   per-project vim instances under tmux, so buffers were naturally isolated based on where
   the vim instance was created from.

   Working in the Emacs GUI, you don't really have that.  Buffers are shared across all frames,
   and if you tend to have multiple projects open (as I do), it can get confusing quickly.

   [[https://github.com/bbatsov/projectile][Projectile]] aims to fix that.
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :demand t
       :diminish t
       :init
       (setq
        projectile-cache-file (concat mattlymacs-cache-dir "projectile.cache")
        projectile-completion-system 'ivy
        projectile-enable-caching (not noninteractive)
        projectile-globally-ignored-directories `(,mattlymacs-local-dir ".sync")
        projectile-globally-ignored-file-suffixes '(".elc")
        projectile-globally-ignored-files '(".DS_Store")
        projectile-indexing-method 'alien
        projectile-known-projects-file (concat mattlymacs-cache-dir "projectile.projects")
        projectile-project-root-files
        '(".git" ".hg" ".project" "package.json"))
       :config
       (add-hook 'mattlymacs-init-hook #'projectile-mode))

   #+END_SRC

** Source Control: Git and Magit
   Sure, I could use mercurial or perforce, but what would that get me? Git is
   it, and [[https://magit.vc][Magit]] is pretty awesome.  I used to prefer the git command line, and 
   came up with all sorts of pithy aliases in my [[https://github.com/mattly/dotfiles/blob/master/configs/gitconfig#L46][gitconfig]] to handle common
   operations.  I had stockholm syndrome for git's poor user interface.  
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :commands (magit-status magit-list-repositories)
       :config
       (setq magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1
             magit-completing-read-function 'ivy-completing-read))
   #+END_SRC

*** Evil for Magit
    I still want evil-bindings everywhere, though.
    #+BEGIN_SRC emacs-lisp
      ;; (use-package evil-magit
      ;;   :init
      ;;   (with-eval-after-load 'magit
      ;;     (require 'evil-magit)))
    #+END_SRC
    
    #+BEGIN_SRC emacs-lisp
      (general-define-key
       :keymaps
       '(magit-mode-map
         magit-status-mode-map
         magit-file-section-map
         magit-unstaged-section-map
         magit-staged-section-map
         magit-refs-mode-map
         magit-blame-mode-map
         magit-hunk-section-map
         magit-diff-mode-map
         magit-log-read-revs-map
         magit-log-mode-map
         magit-log-select-mode-map
         magit-cherry-mode-map
         magit-reflog-mode-map
         magit-process-mode-map
         magit-stash-mode-map)
       "i" 'magit-section-forward-sibling
       "e" 'magit-section-forward
       "n" 'magit-section-backward-sibling
       "u" 'magit-section-backward
       "j" 'magit-unstage
       "J" 'magit-unstage-all)

      (with-eval-after-load 'magit
        (magit-change-popup-key 'magit-dispatch-popup :actions (string-to-char "u") (string-to-char "j"))
        (magit-change-popup-key 'magit-dispatch-popup :actions (string-to-char "U") (string-to-char "J")))
    #+END_SRC

*** Committing
    Best practices for git commits are: 50 character subject lines, separate the
    body with a blank line, and wrap the body at 72 characters. I can enforce those.
    Things like capitalization, imperative in the subject, explain _what_ and
    _why_ vs. _how_, I can't enforce so much.
    #+BEGIN_SRC emacs-lisp
      (use-package git-commit
        :defer t
        :config
        (add-hook 'git-commit-mode-hook #'fci-mode))
    #+END_SRC

*** Git Files (.gitignore, .gitcommit)
    #+BEGIN_SRC emacs-lisp
      (use-package gitattributes-mode
        :defer t)
      (use-package gitconfig-mode
        :defer t)
      (use-package gitignore-mode
        :defer t)
    #+END_SRC
* Lisp
  People who complain about the abundance of parenthesis in lisps miss the
  point.  In over two years of working primarily with lisps full-time, the only
  times I've had to think about managing parenthesis manually was when I was
  making a small edit to something in the GitHub editor or the like.  And sure,
  I usually screw it up.  But the whole point of having parenthesis and spaces
  as your primary syntax delimiters is to enable _structural editing_, a
  powerful idea and practice that's difficult to execute well in languages which
  complicate their syntax away from its strucutre.
  
  If you use an auto-close or auto-pair style plugin, that automatically inserts
  a closing paren, bracket, quote, or such, or highlights its compliement, you 
  already practice a weak form of structural editing -- the editor knows that 
  certain characters form nodes in a syntax tree, and helps to both ensure the
  integrity of that tree and highlight its structure.  Structural editing is that,
  but much more powerful.
  
** Lisp Mode
   #+BEGIN_SRC emacs-lisp
     (defvar lisp-mode-hook nil)
     "A list of hooks to run when entering a lisp mode."

     (defun run-lisp-mode-hook ()
       (run-hooks 'lisp-mode-hook))
   #+END_SRC
  
** Parinfer
   As an initial experiment, I'm seeing how far I can get with the lighter
   weight [[https://shaunlebron.github.io/parinfer/][Parinfer]] before I feel the need to add something a bit heavier.  I used
   parinfer solely when trying out Atom briefly, and while I feel Atom has a long
   way to go before it's really usable for me, I did quite like parinfer.

   #+BEGIN_SRC emacs-lisp
     (use-package parinfer
       :ensure t
       :init
       (progn
         (setq parinfer-extensions
               '(defaults
                  pretty-parens
                  evil
                  smart-yank))
         (add-hook 'lisp-mode-hook #'parinfer-mode)))
   #+END_SRC


* Key Bindings
** At-Rest (Normal & Visual) immediate mappings
   I'm basically mucking with the vim bindings here.
*** Reset
    #+BEGIN_SRC emacs-lisp
      (bind-navigation
       "?" 'which-key-show-top-level)
    #+END_SRC
*** Navigation
    #+BEGIN_SRC emacs-lisp
      ;; (define-key evil-operator-state-map "i" nil)
      (bind-navigation
       "l" 'evil-backward-char
       "u" 'evil-previous-line
       "y" 'evil-forward-char

       "e" 'evil-next-line
       "n" 'evil-backward-word-begin
       "i" 'evil-forward-word-begin
       "o" 'evil-forward-word-end

       "k" 'evil-find-char
       "K" 'evil-find-char-to

       "L" 'back-to-indentation
       "U" 'evil-backward-paragraph
       "Y" 'evil-end-of-line

       "E" 'evil-forward-paragraph
       "N" 'evil-backward-sentence-begin
       "I" 'evil-forward-sentence-begin
       "O" 'evil-forward-WORD-end

       "j" 'evil-scroll-page-up
       "h" 'evil-scroll-page-down
       "J" 'evil-goto-first-line
       "H" 'evil-goto-line

       "'" 'avy-goto-char-2
       "/" '(swiper :which-key "swiper"))

      (define-key evil-operator-state-map "r" evil-inner-text-objects-map)
      (define-key evil-operator-state-map "s" evil-outer-text-objects-map)

    #+END_SRC
*** Modification
    #+BEGIN_SRC emacs-lisp
      (bind-navigation
       "r" 'evil-insert
       "R" 'evil-insert-line
       "s" 'evil-append
       "S" 'evil-append-line
       "t" 'evil-change
       "T" 'evil-change-line
       "q" 'evil-replace
       "Q" 'evil-replace-state
       "z" 'evil-open-below
       "Z" 'evil-open-above
       "d" 'evil-delete
       "D" 'evil-delete-line

       "p" 'undo-tree-undo
       "P" 'undo-tree-redo

       "x" 'evil-delete-char
       "X" 'evil-delete-line
       "c" 'evil-yank
       "C" 'evil-yank-line
       "v" 'evil-paste-after
       "V" 'evil-paste-before

       "a" 'evil-visual-char
       "A" 'evil-visual-line
       "C-a" 'evil-visual-block)
    #+END_SRC
*** Et Cetera
    #+BEGIN_SRC emacs-lisp
      (bind-navigation
       "TAB" '(origami-recursively-toggle-node :which-key "toggle this fold recursively (like org)")
       "M-=" '(zoom-in :which-key "zoom in")
       "M--" '(zoom-out :which-key "zoom out")
       "M-x" '(counsel-M-x :which-key "counsel-M-x"))
    #+END_SRC

** Menu System
   The spacemacs menu-system is one of the best new things I've seen in an
   editor in a long time.  This is my copy.

*** Top-Level
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       "/" '(counsel-rg :which-key "search in current directory")
       "TAB" '(ivy-switch-buffer :which-key "ivy buffer")
       "SPC" '(counsel-M-x :which-key "M-x"))
    #+END_SRC

*** b is for Buffer
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "b"
       "" '(:ignore t :which-key "buffer")
       "b" '(ivy-switch-buffer :which-key "switch")
       "d" '(evil-delete-buffer :which-key "delete")
       "D" '(kill-buffer-and-window :which-key "delete buffer & window"))
    #+END_SRC

*** f is for Files
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "f"
       "" '(:ignore t :which-key "file")
       "D" '(delete-file :which-key "delete (any file)")
       "f" '(counsel-find-file :which-key "find file")
       "r" '(counsel-recentf :which-key "recent files")
       "R" '(rename-file :which-key "rename (any file)")
       "s" '(save-buffer :which-key "save"))
    #+END_SRC

*** g is for Git
    I feel a bit bad about this, maybe it should be under =v= for Version
    Control? But I mean, I haven't touched another VCS aside from just toying
    around in like 8 years. So git it is.
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "g"
       "" '(:ignore t :which-key "git")
       "b" '(magit-blame :which-key "blame")
       "f" '(counsel-git :which-key "find file")
       "g" '(counsel-git-grep :which-key "git grep")
       "s" '(magit-status :which-key "status"))
    #+END_SRC

*** h is for Help
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "h"
       "" '(:ignore t :which-key "help")
       "f" '(counsel-describe-function :which-key "describe function")
       "F" '(counsel-describe-face :which-key "describe face")
       "k" '(describe-key :which-key "describe key")
       "v" '(counsel-describe-variable :which-key "describe variable"))
    #+END_SRC

*** p is for Project
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "p"
       "" '(:ignore t :which-key "project")
       "b" '(projectile-switch-to-buffer :which-key "switch buffer")
       "f" '(projectile-find-file :which-key "find file")
       "p" '(projectile-switch-project :which-key "switch project")
       "r" '(projectile-recentf :which-key "recent files")
       "x" '(projectile-invalidate-cache :which-key "invalidate cache"))
    #+END_SRC

*** q is for Quitters
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "q"
       "" '(:ignore t :which-key "quit")
       "r" '(restart-emacs :which-key "restart")
       "q" '(evil-save-and-quit :which-key "quit and save"))
    #+END_SRC

*** t is for Toggles
    I'm using a hydra for this because I can make it show me if a toggle is
    enabled or not.
    #+BEGIN_SRC emacs-lisp
      (defhydra mattly-toggles (:color pink)
        "
      _f_ fill column indicator:   %`fci-mode
      _F_ auto line breaking:      %`auto-fill-function
      _p_ smartparens:             %`smartparens-mode
      _w_ whitespace display:      %`whitespace-mode
      "
        ("f" fci-mode nil)
        ("F" auto-fill-mode nil)
        ("p" smartparens-mode nil)
        ("w" whitespace-mode nil)
        ("q" nil "cancel"))

      (bind-main-menu
       "t" '(mattly-toggles/body :which-key "toggles"))
    #+END_SRC

*** u is for User Interface
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "u"
       "-" '(zoom-out :which-key "zoom out")
       "=" '(zoom-in :which-key "zoom in")
       "0" '(zoom-frm-unzoom :which-key "zoom reset"))
    #+END_SRC
*** w is for Windows
    The vim/emacs notion of a window, that is. What you'd call a "pane" or
    "split" in a more modern program.
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "w"
       "" '(:ignore t :which-key "window")
       "u" '(evil-window-up :which-key "go window up")
       "e" '(evil-window-down :which-key "go window down")
       "n" '(evil-window-left :which-key "go window left")
       "i" '(evil-window-right :which-key "go window right")
       "m" '(:ignore t :which-key "move")
       "m u" '(evil-window-move-very-top :which-key "window far top")
       "m e" '(evil-window-move-very-bottom :which-key "window far bottom")
       "m n" '(evil-window-move-far-left :which-key "window far left")
       "m i" '(evil-window-move-far-right :which-key "window far right")
       "s" '(evil-window-split :which-key "split left")
       "v" '(evil-window-vsplit :which-key "split below")
       "d" '(evil-window-delete :which-key "delete window"))
    #+END_SRC

*** x is for Text
    OK this one is a bit of a stretch. At least the letter is in the item? And
    I'm used to it from spacemacs.
    #+BEGIN_SRC emacs-lisp
      (bind-main-menu
       :infix "x"
       "" '(:ignore t :which-key "text")
       "i" '(:ignore t :which-key "inflection")
       "i c" '(string-inflection-lower-camelcase :which-key "camelCase")
       "i C" '(string-inflection-camelcase :which-key "CamelCase")
       "i -" '(string-inflection-kebab-case :which-key "kebab-case")
       "i k" '(string-inflection-kebab-case :which-key "kebab-case")
       "i _" '(string-inflection-underscore :which-key "under_score") ;; you hate me
       "i u" '(string-inflection-underscore :which-key "under_score") ;; why do you hate me?
       "i U" '(string-inflection-upcase :which-key "UP_CASE")) ;; oh right you think `-` is math because you have a crap parser.
    #+END_SRC

*** z is for Folding
    This is even more of a stretch. But it ties into existing folding under
    =z=. I'm using a hydra for this because it makes naviation easier.
    #+BEGIN_SRC emacs-lisp
      (defhydra mattly|folding (:color pink)
        "
      Close^^          Open^^           Toggle^^        Goto^^
      -----^^--------- ----^^---------- ------^^------- ----^^----
      _c_: at point    _o_: at point    _a_: at point   _n_: next
      _C_: recursively _O_: recursively _A_: all        _p_: previous
      _m_: all         _r_: all         _TAB_: like org
      "
        ("c" origami-close-node)
        ("C" origami-close-node-recursively)
        ("m" origami-close-all-nodes)
        ("o" origami-open-node)
        ("O" origami-open-node-recursively)
        ("a" origami-forward-toggle-node)
        ("r" origami-open-all-nodes)
        ("A" origami-toggle-all-nodes)
        ("TAB" origami-recursively-toggle-node)
        ("<tab>" origami-recursively-toggle-node)
        ("n" origami-next-fold)
        ("p" origami-previous-fold)
        ("q" nil :exit t)
        ("C-g" nil :exit t)
        ("<SPC>" nil :exit t))

      (bind-main-menu
       "z" '(mattly|folding/body :which-key "folding"))
    #+END_SRC

*** \ is for This Config
    The stretchiest stretch of them all.
    #+BEGIN_SRC emacs-lisp 
      (bind-main-menu
       :infix "\\"
       "" '(:ignore t :which-key "config")
       "d" '(mattly|find-dotfile :which-key "find config.org")
       "p" '(auto-package-update-now :which-key "update packages")
       "r" '(mattly|reload-init :which-key "reload"))
    #+END_SRC
   
   
* Major & Minor Modes (file types, languages, etc)
** Clojure
   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :defer t
       :init
       (progn
         (add-to-list 'auto-mode-alist '("\\.boot\\'" . clojure-mode))
         (add-to-list 'magic-mode-alist '("#!.*boot\\s-*$" . clojure-mode)))
       :config
       (add-hook 'clojure-mode-hook #'run-lisp-mode-hook))
   #+END_SRC
** Emacs Lisp
   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-lisp-mode-hook #'run-lisp-mode-hook)
   #+END_SRC
** Markdown
   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :defer t)
   #+END_SRC
** Org
   Org is as close to a realization of the editable, interactive, embeddable
   content varietal document as I've seen since Steve Jobs killed OpenDoc back
   in the 90s. Aping that was one of the first things I tried to do as a personal
   project after I first learned how to program something more complicated than a
   shell script. I failed because, well, I wasn't ready yet. Twelve years later,
   I'm still not ready, so I use org-mode.
   #+BEGIN_SRC emacs-lisp
     (use-package org-plus-contrib
       :defer t
       :config
       (sp-with-modes '(org-mode)
         (sp-local-pair "\\[" "\\]" :post-handlers '(("|" "SPC")))
         (sp-local-pair "\\(" "\\)" :post-handlers '(("|" "SPC")))
         (sp-local-pair "$$" "$$" :post-handlers '((:add " | ")) :unless '(sp-point-at-bol-p))
         (sp-local-pair "{" nil)))
   #+END_SRC
*** org packages
**** org-bullets
    Yeah so org-bullets is one of those eye candy things that actually makes it
    feel like you're not really using a forty-year old program. That counts
    for something.
    #+BEGIN_SRC emacs-lisp
      (use-package org-bullets
        :defer t
        :commands (org-bullets-mode)
        :init
        (setq org-bullets-bullet-list '("§" "𝟤" "𝟥" "𝟦" "𝟧" "𝟨" "𝟩" "𝟪" "𝟫"))
        (setq org-bullets-face-name 'org-bullet)
        (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
    #+END_SRC
   
**** org-babel
     What languages do we want org to handle?
     #+BEGIN_SRC emacs-lisp
       (setq org-babel-load-languages '())
       (defvar mattly|org-babel-load-languages
         '(emacs-lisp))
     #+END_SRC

     Babel is included with org, though apparently available as =ob= on the
     (insecure) org repository. Instead of using =use-package= just configure it
     in a function called by the org's =:config= option.
     #+BEGIN_SRC emacs-lisp
       (defun +org|init-babel ()
         (setq org-src-fontify-natively t
               org-src-tab-acts-natively t
               org-src-window-setup 'other-window)

         (org-babel-do-load-languages
          'org-babel-load-languages
          (mapcar (lambda (sym) (cons sym t)) mattly|org-babel-load-languages))

         (add-hook 'org-src-mode-hook
                   (lambda () (when header-line-format (setq header-line-format nil)))))

       (add-hook 'org-mode-hook #'+org|init-babel)
       (add-hook 'mattlymacs-init-hook #'+org|init-babel)
     #+END_SRC

**** org-evil
     =org-evil= defines some [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/keythemes.org][useful key bindings]] and has some duplication with
     the bindings I declare below, but it also has movement by element and
     additional text objects like =e= for an object and =E= for an element.
     #+BEGIN_SRC emacs-lisp
       (use-package org-evil
         :defer t
         :diminish t
         :after org
         :config)
         ;; (add-hook 'org-mode-hook 'evil-org-mode)
         ;; (add-hook 'evil-org-mode-hook
         ;;     (lambda () (evil-org-set-key-theme)))
   
     #+END_SRC
*** key bindings
    I was hoping to make an evil-mode similar to spacemacs' =evil-lisp-state=
    but I couldn't figure out how to do it in a way that keeps =which-key= in
    view the way spacemacs does. And, sadly, these operations aren't things I
    have in muscle memory yet, and they won't ever get there without on-screen
    reminders about which-keys I have to press. So, I'm using =hydra= for now,
    which seems to be awesome in its own right.

    - bindings for table editing
    
   #+BEGIN_SRC emacs-lisp
     (general-define-key
      :states '(normal visual operator)
      :keymaps 'org-mode-map
      "RET" 'org-return-indent)

     (bind-mode-menu
      :keymaps 'org-mode-map
      "c" '(org-edit-special :which-key "edit special")
      "d" '(org-insert-drawer :which-key "insert drawer")
      "h" '(org-insert-heading-respect-content :which-key "insert heading after")
      "H" '(org-insert-subheading :which-key "insert subheading here")
      "t" '(org-table-create :which-key "create table"))

     (defhydra mattly|hydra-org-structure (:color pink)
       "
     ^Nav^               ^Subtree^          ^Node^
     ^^^^^^^^^-----------------------------------------------
     _h_: up heading     _H_: promote       _N_: promote
     _j_: next heading   _J_: move down     _P_: demote
     _k_: prev heading   _K_: move up
     _n_: next sibling   _L_: demote
     _p_: prev sibling

     "
       ("h" outline-up-heading)
       ("j" org-next-visible-heading)
       ("k" org-previous-visible-heading)
       ("n" org-forward-heading-same-level)
       ("p" org-backward-heading-same-level)
       ("H" org-promote-subtree)
       ("J" org-move-subtree-down)
       ("K" org-move-subtree-up)
       ("L" org-demote-subtree)
       ("N" org-do-promote)
       ("P" org-do-demote)
       ("q" nil "quit")
       ("ESC" nil "quit"))

     (general-define-key
      :prefix "SPC"
      :states '(normal visual operator)
      :keymaps 'org-mode-map
      "k" '(mattly|hydra-org-structure/body :which-key "org structure"))

     (general-define-key
      :prefix ","
      :states '(normal visual)
      :keymaps 'org-src-mode-map
      "c" '(org-edit-src-exit :which-key "save and exit")
      "," '(org-edit-src-exit :which-key "save and exit")
      "k" '(org-edit-src-abort :which-key "abort and exit"))
  #+END_SRC
